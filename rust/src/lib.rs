// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_METADATA_KEY: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_METADATA_KEY: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_METADATA_KEY: [MetadataKey; 4] = [
  MetadataKey::UNKNOWN,
  MetadataKey::NEXTCODE,
  MetadataKey::CODEPATH,
  MetadataKey::LAYOUT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MetadataKey(pub u8);
#[allow(non_upper_case_globals)]
impl MetadataKey {
  pub const UNKNOWN: Self = Self(0);
  pub const NEXTCODE: Self = Self(1);
  pub const CODEPATH: Self = Self(2);
  pub const LAYOUT: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::NEXTCODE,
    Self::CODEPATH,
    Self::LAYOUT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNKNOWN => Some("UNKNOWN"),
      Self::NEXTCODE => Some("NEXTCODE"),
      Self::CODEPATH => Some("CODEPATH"),
      Self::LAYOUT => Some("LAYOUT"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for MetadataKey {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MetadataKey {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for MetadataKey {
    type Output = MetadataKey;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for MetadataKey {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MetadataKey {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MetadataKey {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MARKER: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MARKER: u8 = 31;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MARKER: [Marker; 27] = [
  Marker::SENTINEL,
  Marker::SOH,
  Marker::EOE,
  Marker::SOO,
  Marker::EOO,
  Marker::SOA,
  Marker::EOA,
  Marker::AED,
  Marker::AEE,
  Marker::TEXT,
  Marker::FRAG,
  Marker::INT8,
  Marker::UINT8,
  Marker::INT16,
  Marker::UINT16,
  Marker::INT32,
  Marker::UINT32,
  Marker::DATE32,
  Marker::FLT32,
  Marker::INT64,
  Marker::UINT64,
  Marker::DATE64,
  Marker::FLT64,
  Marker::BOOL,
  Marker::NULL,
  Marker::JSON,
  Marker::MAX,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Marker(pub u8);
#[allow(non_upper_case_globals)]
impl Marker {
  pub const SENTINEL: Self = Self(0);
  pub const SOH: Self = Self(1);
  pub const EOE: Self = Self(2);
  pub const SOO: Self = Self(3);
  pub const EOO: Self = Self(4);
  pub const SOA: Self = Self(5);
  pub const EOA: Self = Self(6);
  pub const AED: Self = Self(7);
  pub const AEE: Self = Self(8);
  pub const TEXT: Self = Self(9);
  pub const FRAG: Self = Self(10);
  pub const INT8: Self = Self(11);
  pub const UINT8: Self = Self(12);
  pub const INT16: Self = Self(13);
  pub const UINT16: Self = Self(14);
  pub const INT32: Self = Self(15);
  pub const UINT32: Self = Self(16);
  pub const DATE32: Self = Self(17);
  pub const FLT32: Self = Self(18);
  pub const INT64: Self = Self(19);
  pub const UINT64: Self = Self(20);
  pub const DATE64: Self = Self(21);
  pub const FLT64: Self = Self(22);
  pub const BOOL: Self = Self(23);
  pub const NULL: Self = Self(24);
  pub const JSON: Self = Self(25);
  pub const MAX: Self = Self(31);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 31;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SENTINEL,
    Self::SOH,
    Self::EOE,
    Self::SOO,
    Self::EOO,
    Self::SOA,
    Self::EOA,
    Self::AED,
    Self::AEE,
    Self::TEXT,
    Self::FRAG,
    Self::INT8,
    Self::UINT8,
    Self::INT16,
    Self::UINT16,
    Self::INT32,
    Self::UINT32,
    Self::DATE32,
    Self::FLT32,
    Self::INT64,
    Self::UINT64,
    Self::DATE64,
    Self::FLT64,
    Self::BOOL,
    Self::NULL,
    Self::JSON,
    Self::MAX,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SENTINEL => Some("SENTINEL"),
      Self::SOH => Some("SOH"),
      Self::EOE => Some("EOE"),
      Self::SOO => Some("SOO"),
      Self::EOO => Some("EOO"),
      Self::SOA => Some("SOA"),
      Self::EOA => Some("EOA"),
      Self::AED => Some("AED"),
      Self::AEE => Some("AEE"),
      Self::TEXT => Some("TEXT"),
      Self::FRAG => Some("FRAG"),
      Self::INT8 => Some("INT8"),
      Self::UINT8 => Some("UINT8"),
      Self::INT16 => Some("INT16"),
      Self::UINT16 => Some("UINT16"),
      Self::INT32 => Some("INT32"),
      Self::UINT32 => Some("UINT32"),
      Self::DATE32 => Some("DATE32"),
      Self::FLT32 => Some("FLT32"),
      Self::INT64 => Some("INT64"),
      Self::UINT64 => Some("UINT64"),
      Self::DATE64 => Some("DATE64"),
      Self::FLT64 => Some("FLT64"),
      Self::BOOL => Some("BOOL"),
      Self::NULL => Some("NULL"),
      Self::JSON => Some("JSON"),
      Self::MAX => Some("MAX"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Marker {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Marker {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Marker {
    type Output = Marker;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Marker {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Marker {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Marker {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONSTANT: u8 = 32;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONSTANT: u8 = 64;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONSTANT: [Constant; 2] = [
  Constant::FRAGMENT,
  Constant::BATCH_SZ,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Constant(pub u8);
#[allow(non_upper_case_globals)]
impl Constant {
  pub const FRAGMENT: Self = Self(32);
  pub const BATCH_SZ: Self = Self(64);

  pub const ENUM_MIN: u8 = 32;
  pub const ENUM_MAX: u8 = 64;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FRAGMENT,
    Self::BATCH_SZ,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FRAGMENT => Some("FRAGMENT"),
      Self::BATCH_SZ => Some("BATCH_SZ"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Constant {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Constant {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Constant {
    type Output = Constant;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Constant {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Constant {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Constant {}
pub enum HybridFMIOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HybridFMI<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HybridFMI<'a> {
    type Inner = HybridFMI<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> HybridFMI<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HybridFMI { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HybridFMIArgs<'args>) -> flatbuffers::WIPOffset<HybridFMI<'bldr>> {
      let mut builder = HybridFMIBuilder::new(_fbb);
      if let Some(x) = args.bv_data { builder.add_bv_data(x); }
      if let Some(x) = args.bv_len { builder.add_bv_len(x); }
      if let Some(x) = args.hist_freq { builder.add_hist_freq(x); }
      if let Some(x) = args.hist_char { builder.add_hist_char(x); }
      if let Some(x) = args.hist_len { builder.add_hist_len(x); }
      if let Some(x) = args.format { builder.add_format(x); }
      if let Some(x) = args.index_char { builder.add_index_char(x); }
      builder.add_len(args.len);
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_LEN: flatbuffers::VOffsetT = 6;
    pub const VT_INDEX_CHAR: flatbuffers::VOffsetT = 8;
    pub const VT_FORMAT: flatbuffers::VOffsetT = 10;
    pub const VT_HIST_LEN: flatbuffers::VOffsetT = 12;
    pub const VT_HIST_CHAR: flatbuffers::VOffsetT = 14;
    pub const VT_HIST_FREQ: flatbuffers::VOffsetT = 16;
    pub const VT_BV_LEN: flatbuffers::VOffsetT = 18;
    pub const VT_BV_DATA: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn version(&self) -> u8 {
    self._tab.get::<u8>(HybridFMI::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn len(&self) -> u32 {
    self._tab.get::<u32>(HybridFMI::VT_LEN, Some(0)).unwrap()
  }
  #[inline]
  pub fn index_char(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(HybridFMI::VT_INDEX_CHAR, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn format(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(HybridFMI::VT_FORMAT, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn hist_len(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(HybridFMI::VT_HIST_LEN, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn hist_char(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(HybridFMI::VT_HIST_CHAR, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn hist_freq(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(HybridFMI::VT_HIST_FREQ, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn bv_len(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(HybridFMI::VT_BV_LEN, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn bv_data(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(HybridFMI::VT_BV_DATA, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for HybridFMI<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>(&"version", Self::VT_VERSION, false)?
     .visit_field::<u32>(&"len", Self::VT_LEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"index_char", Self::VT_INDEX_CHAR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"format", Self::VT_FORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"hist_len", Self::VT_HIST_LEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"hist_char", Self::VT_HIST_CHAR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"hist_freq", Self::VT_HIST_FREQ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"bv_len", Self::VT_BV_LEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"bv_data", Self::VT_BV_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct HybridFMIArgs<'a> {
    pub version: u8,
    pub len: u32,
    pub index_char: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub format: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub hist_len: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub hist_char: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub hist_freq: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub bv_len: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub bv_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for HybridFMIArgs<'a> {
    #[inline]
    fn default() -> Self {
        HybridFMIArgs {
            version: 0,
            len: 0,
            index_char: None,
            format: None,
            hist_len: None,
            hist_char: None,
            hist_freq: None,
            bv_len: None,
            bv_data: None,
        }
    }
}
pub struct HybridFMIBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HybridFMIBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u8) {
    self.fbb_.push_slot::<u8>(HybridFMI::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_len(&mut self, len: u32) {
    self.fbb_.push_slot::<u32>(HybridFMI::VT_LEN, len, 0);
  }
  #[inline]
  pub fn add_index_char(&mut self, index_char: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HybridFMI::VT_INDEX_CHAR, index_char);
  }
  #[inline]
  pub fn add_format(&mut self, format: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HybridFMI::VT_FORMAT, format);
  }
  #[inline]
  pub fn add_hist_len(&mut self, hist_len: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HybridFMI::VT_HIST_LEN, hist_len);
  }
  #[inline]
  pub fn add_hist_char(&mut self, hist_char: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HybridFMI::VT_HIST_CHAR, hist_char);
  }
  #[inline]
  pub fn add_hist_freq(&mut self, hist_freq: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HybridFMI::VT_HIST_FREQ, hist_freq);
  }
  #[inline]
  pub fn add_bv_len(&mut self, bv_len: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HybridFMI::VT_BV_LEN, bv_len);
  }
  #[inline]
  pub fn add_bv_data(&mut self, bv_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HybridFMI::VT_BV_DATA, bv_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HybridFMIBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HybridFMIBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HybridFMI<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for HybridFMI<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("HybridFMI");
      ds.field("version", &self.version());
      ds.field("len", &self.len());
      ds.field("index_char", &self.index_char());
      ds.field("format", &self.format());
      ds.field("hist_len", &self.hist_len());
      ds.field("hist_char", &self.hist_char());
      ds.field("hist_freq", &self.hist_freq());
      ds.field("bv_len", &self.bv_len());
      ds.field("bv_data", &self.bv_data());
      ds.finish()
  }
}
pub enum MetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Metadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Metadata<'a> {
    type Inner = Metadata<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Metadata<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Metadata { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MetadataArgs<'args>) -> flatbuffers::WIPOffset<Metadata<'bldr>> {
      let mut builder = MetadataBuilder::new(_fbb);
      if let Some(x) = args.da { builder.add_da(x); }
      if let Some(x) = args.offset { builder.add_offset(x); }
      if let Some(x) = args.unicode { builder.add_unicode(x); }
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_OFFSET: flatbuffers::VOffsetT = 6;
    pub const VT_DA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn unicode(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Metadata::VT_UNICODE, None)
  }
  #[inline]
  pub fn offset(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Metadata::VT_OFFSET, None)
  }
  #[inline]
  pub fn da(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Metadata::VT_DA, None)
  }
}

impl flatbuffers::Verifiable for Metadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"offset", Self::VT_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"da", Self::VT_DA, false)?
     .finish();
    Ok(())
  }
}
pub struct MetadataArgs<'a> {
    pub unicode: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub offset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub da: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for MetadataArgs<'a> {
    #[inline]
    fn default() -> Self {
        MetadataArgs {
            unicode: None,
            offset: None,
            da: None,
        }
    }
}
pub struct MetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetadataBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_UNICODE, unicode);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_OFFSET, offset);
  }
  #[inline]
  pub fn add_da(&mut self, da: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_DA, da);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Metadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Metadata<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Metadata");
      ds.field("unicode", &self.unicode());
      ds.field("offset", &self.offset());
      ds.field("da", &self.da());
      ds.finish()
  }
}
pub enum TextColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TextColumnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TextColumnar<'a> {
    type Inner = TextColumnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> TextColumnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TextColumnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TextColumnarArgs<'args>) -> flatbuffers::WIPOffset<TextColumnar<'bldr>> {
      let mut builder = TextColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(TextColumnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(TextColumnar::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for TextColumnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct TextColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for TextColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        TextColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct TextColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TextColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(TextColumnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TextColumnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TextColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TextColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TextColumnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for TextColumnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("TextColumnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum BoolColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoolColumnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoolColumnar<'a> {
    type Inner = BoolColumnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> BoolColumnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BoolColumnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BoolColumnarArgs<'args>) -> flatbuffers::WIPOffset<BoolColumnar<'bldr>> {
      let mut builder = BoolColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(BoolColumnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a [bool]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(BoolColumnar::VT_VALUE, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for BoolColumnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BoolColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
}
impl<'a> Default for BoolColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        BoolColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct BoolColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BoolColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(BoolColumnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoolColumnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoolColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BoolColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoolColumnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for BoolColumnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("BoolColumnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum NullColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NullColumnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NullColumnar<'a> {
    type Inner = NullColumnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> NullColumnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NullColumnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NullColumnarArgs<'args>) -> flatbuffers::WIPOffset<NullColumnar<'bldr>> {
      let mut builder = NullColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(NullColumnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(NullColumnar::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for NullColumnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct NullColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for NullColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        NullColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct NullColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NullColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(NullColumnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NullColumnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NullColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NullColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NullColumnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for NullColumnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("NullColumnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum Uint8ColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Uint8Columnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uint8Columnar<'a> {
    type Inner = Uint8Columnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Uint8Columnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Uint8Columnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Uint8ColumnarArgs<'args>) -> flatbuffers::WIPOffset<Uint8Columnar<'bldr>> {
      let mut builder = Uint8ColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(Uint8Columnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Uint8Columnar::VT_VALUE, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Uint8Columnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Uint8ColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for Uint8ColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        Uint8ColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct Uint8ColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Uint8ColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Uint8Columnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Uint8Columnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Uint8ColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Uint8ColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uint8Columnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Uint8Columnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Uint8Columnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum Int8ColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int8Columnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int8Columnar<'a> {
    type Inner = Int8Columnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Int8Columnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Int8Columnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Int8ColumnarArgs<'args>) -> flatbuffers::WIPOffset<Int8Columnar<'bldr>> {
      let mut builder = Int8ColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(Int8Columnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a [i8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(Int8Columnar::VT_VALUE, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Int8Columnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Int8ColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for Int8ColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        Int8ColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct Int8ColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Int8ColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Int8Columnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Int8Columnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Int8ColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Int8ColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Int8Columnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Int8Columnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Int8Columnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum Uint16ColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Uint16Columnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uint16Columnar<'a> {
    type Inner = Uint16Columnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Uint16Columnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Uint16Columnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Uint16ColumnarArgs<'args>) -> flatbuffers::WIPOffset<Uint16Columnar<'bldr>> {
      let mut builder = Uint16ColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(Uint16Columnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Uint16Columnar::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for Uint16Columnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Uint16ColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for Uint16ColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        Uint16ColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct Uint16ColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Uint16ColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Uint16Columnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Uint16Columnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Uint16ColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Uint16ColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uint16Columnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Uint16Columnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Uint16Columnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum Int16ColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int16Columnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int16Columnar<'a> {
    type Inner = Int16Columnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Int16Columnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Int16Columnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Int16ColumnarArgs<'args>) -> flatbuffers::WIPOffset<Int16Columnar<'bldr>> {
      let mut builder = Int16ColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(Int16Columnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, i16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i16>>>(Int16Columnar::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for Int16Columnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i16>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Int16ColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i16>>>,
}
impl<'a> Default for Int16ColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        Int16ColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct Int16ColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Int16ColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Int16Columnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Int16Columnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Int16ColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Int16ColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Int16Columnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Int16Columnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Int16Columnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum Uint32ColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Uint32Columnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uint32Columnar<'a> {
    type Inner = Uint32Columnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Uint32Columnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Uint32Columnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Uint32ColumnarArgs<'args>) -> flatbuffers::WIPOffset<Uint32Columnar<'bldr>> {
      let mut builder = Uint32ColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(Uint32Columnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Uint32Columnar::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for Uint32Columnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Uint32ColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for Uint32ColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        Uint32ColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct Uint32ColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Uint32ColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Uint32Columnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Uint32Columnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Uint32ColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Uint32ColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uint32Columnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Uint32Columnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Uint32Columnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum Int32ColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int32Columnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int32Columnar<'a> {
    type Inner = Int32Columnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Int32Columnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Int32Columnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Int32ColumnarArgs<'args>) -> flatbuffers::WIPOffset<Int32Columnar<'bldr>> {
      let mut builder = Int32ColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(Int32Columnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Int32Columnar::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for Int32Columnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Int32ColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for Int32ColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        Int32ColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct Int32ColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Int32ColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Int32Columnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Int32Columnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Int32ColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Int32ColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Int32Columnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Int32Columnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Int32Columnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum Uint64ColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Uint64Columnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uint64Columnar<'a> {
    type Inner = Uint64Columnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Uint64Columnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Uint64Columnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Uint64ColumnarArgs<'args>) -> flatbuffers::WIPOffset<Uint64Columnar<'bldr>> {
      let mut builder = Uint64ColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(Uint64Columnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Uint64Columnar::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for Uint64Columnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Uint64ColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for Uint64ColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        Uint64ColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct Uint64ColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Uint64ColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Uint64Columnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Uint64Columnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Uint64ColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Uint64ColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uint64Columnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Uint64Columnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Uint64Columnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum Int64ColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int64Columnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int64Columnar<'a> {
    type Inner = Int64Columnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Int64Columnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Int64Columnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Int64ColumnarArgs<'args>) -> flatbuffers::WIPOffset<Int64Columnar<'bldr>> {
      let mut builder = Int64ColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(Int64Columnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(Int64Columnar::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for Int64Columnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Int64ColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for Int64ColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        Int64ColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct Int64ColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Int64ColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Int64Columnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Int64Columnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Int64ColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Int64ColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Int64Columnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Int64Columnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Int64Columnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum Float32ColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Float32Columnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Float32Columnar<'a> {
    type Inner = Float32Columnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Float32Columnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Float32Columnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Float32ColumnarArgs<'args>) -> flatbuffers::WIPOffset<Float32Columnar<'bldr>> {
      let mut builder = Float32ColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(Float32Columnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(Float32Columnar::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for Float32Columnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Float32ColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for Float32ColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        Float32ColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct Float32ColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Float32ColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Float32Columnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Float32Columnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Float32ColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Float32ColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Float32Columnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Float32Columnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Float32Columnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum Float64ColumnarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Float64Columnar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Float64Columnar<'a> {
    type Inner = Float64Columnar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Float64Columnar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Float64Columnar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Float64ColumnarArgs<'args>) -> flatbuffers::WIPOffset<Float64Columnar<'bldr>> {
      let mut builder = Float64ColumnarBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn metadata(&self) -> Option<Metadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(Float64Columnar::VT_METADATA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Float64Columnar::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for Float64Columnar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Float64ColumnarArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for Float64ColumnarArgs<'a> {
    #[inline]
    fn default() -> Self {
        Float64ColumnarArgs {
            metadata: None,
            value: None,
        }
    }
}
pub struct Float64ColumnarBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Float64ColumnarBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Float64Columnar::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Float64Columnar::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Float64ColumnarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Float64ColumnarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Float64Columnar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Float64Columnar<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Float64Columnar");
      ds.field("metadata", &self.metadata());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ArrayBracketOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArrayBracket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayBracket<'a> {
    type Inner = ArrayBracket<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ArrayBracket<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ArrayBracket { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ArrayBracketArgs<'args>) -> flatbuffers::WIPOffset<ArrayBracket<'bldr>> {
      let mut builder = ArrayBracketBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.da { builder.add_da(x); }
      if let Some(x) = args.value_offset { builder.add_value_offset(x); }
      if let Some(x) = args.offset { builder.add_offset(x); }
      if let Some(x) = args.unicode { builder.add_unicode(x); }
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_OFFSET: flatbuffers::VOffsetT = 6;
    pub const VT_VALUE_OFFSET: flatbuffers::VOffsetT = 8;
    pub const VT_DA: flatbuffers::VOffsetT = 10;
    pub const VT_VALUE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn unicode(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(ArrayBracket::VT_UNICODE, None)
  }
  #[inline]
  pub fn offset(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(ArrayBracket::VT_OFFSET, None)
  }
  #[inline]
  pub fn value_offset(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(ArrayBracket::VT_VALUE_OFFSET, None)
  }
  #[inline]
  pub fn da(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(ArrayBracket::VT_DA, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(ArrayBracket::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for ArrayBracket<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"offset", Self::VT_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"value_offset", Self::VT_VALUE_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"da", Self::VT_DA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayBracketArgs<'a> {
    pub unicode: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub offset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub value_offset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub da: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for ArrayBracketArgs<'a> {
    #[inline]
    fn default() -> Self {
        ArrayBracketArgs {
            unicode: None,
            offset: None,
            value_offset: None,
            da: None,
            value: None,
        }
    }
}
pub struct ArrayBracketBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayBracketBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayBracket::VT_UNICODE, unicode);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayBracket::VT_OFFSET, offset);
  }
  #[inline]
  pub fn add_value_offset(&mut self, value_offset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayBracket::VT_VALUE_OFFSET, value_offset);
  }
  #[inline]
  pub fn add_da(&mut self, da: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayBracket::VT_DA, da);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayBracket::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayBracketBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayBracketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayBracket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ArrayBracket<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ArrayBracket");
      ds.field("unicode", &self.unicode());
      ds.field("offset", &self.offset());
      ds.field("value_offset", &self.value_offset());
      ds.field("da", &self.da());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ArrayElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArrayElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayElement<'a> {
    type Inner = ArrayElement<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ArrayElement<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ArrayElement { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ArrayElementArgs<'args>) -> flatbuffers::WIPOffset<ArrayElement<'bldr>> {
      let mut builder = ArrayElementBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.offset { builder.add_offset(x); }
      if let Some(x) = args.unicode { builder.add_unicode(x); }
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_OFFSET: flatbuffers::VOffsetT = 6;
    pub const VT_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn unicode(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(ArrayElement::VT_UNICODE, None)
  }
  #[inline]
  pub fn offset(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(ArrayElement::VT_OFFSET, None)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(ArrayElement::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for ArrayElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"offset", Self::VT_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayElementArgs<'a> {
    pub unicode: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub offset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for ArrayElementArgs<'a> {
    #[inline]
    fn default() -> Self {
        ArrayElementArgs {
            unicode: None,
            offset: None,
            value: None,
        }
    }
}
pub struct ArrayElementBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayElementBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayElement::VT_UNICODE, unicode);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayElement::VT_OFFSET, offset);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayElement::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayElementBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ArrayElement<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ArrayElement");
      ds.field("unicode", &self.unicode());
      ds.field("offset", &self.offset());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ContentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Content<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Content<'a> {
    type Inner = Content<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Content<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Content { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ContentArgs<'args>) -> flatbuffers::WIPOffset<Content<'bldr>> {
      let mut builder = ContentBuilder::new(_fbb);
      if let Some(x) = args.da { builder.add_da(x); }
      if let Some(x) = args.hfmi { builder.add_hfmi(x); }
      builder.finish()
    }

    pub const VT_HFMI: flatbuffers::VOffsetT = 4;
    pub const VT_DA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn hfmi(&self) -> Option<HybridFMI<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<HybridFMI>>(Content::VT_HFMI, None)
  }
  #[inline]
  pub fn da(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Content::VT_DA, None)
  }
}

impl flatbuffers::Verifiable for Content<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<HybridFMI>>(&"hfmi", Self::VT_HFMI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"da", Self::VT_DA, false)?
     .finish();
    Ok(())
  }
}
pub struct ContentArgs<'a> {
    pub hfmi: Option<flatbuffers::WIPOffset<HybridFMI<'a>>>,
    pub da: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for ContentArgs<'a> {
    #[inline]
    fn default() -> Self {
        ContentArgs {
            hfmi: None,
            da: None,
        }
    }
}
pub struct ContentBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ContentBuilder<'a, 'b> {
  #[inline]
  pub fn add_hfmi(&mut self, hfmi: flatbuffers::WIPOffset<HybridFMI<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<HybridFMI>>(Content::VT_HFMI, hfmi);
  }
  #[inline]
  pub fn add_da(&mut self, da: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Content::VT_DA, da);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContentBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ContentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Content<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Content<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Content");
      ds.field("hfmi", &self.hfmi());
      ds.field("da", &self.da());
      ds.finish()
  }
}
pub enum SemiStructuredDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SemiStructuredData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SemiStructuredData<'a> {
    type Inner = SemiStructuredData<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SemiStructuredData<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SemiStructuredData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SemiStructuredDataArgs<'args>) -> flatbuffers::WIPOffset<SemiStructuredData<'bldr>> {
      let mut builder = SemiStructuredDataBuilder::new(_fbb);
      if let Some(x) = args.i8_ { builder.add_i8_(x); }
      if let Some(x) = args.u8_ { builder.add_u8_(x); }
      if let Some(x) = args.i16_ { builder.add_i16_(x); }
      if let Some(x) = args.u16_ { builder.add_u16_(x); }
      if let Some(x) = args.d32 { builder.add_d32(x); }
      if let Some(x) = args.i32_ { builder.add_i32_(x); }
      if let Some(x) = args.u32_ { builder.add_u32_(x); }
      if let Some(x) = args.d64 { builder.add_d64(x); }
      if let Some(x) = args.i64_ { builder.add_i64_(x); }
      if let Some(x) = args.u64_ { builder.add_u64_(x); }
      if let Some(x) = args.f32_ { builder.add_f32_(x); }
      if let Some(x) = args.f64_ { builder.add_f64_(x); }
      if let Some(x) = args.null { builder.add_null(x); }
      if let Some(x) = args.bool { builder.add_bool(x); }
      if let Some(x) = args.text { builder.add_text(x); }
      if let Some(x) = args.array_element { builder.add_array_element(x); }
      if let Some(x) = args.array_bracket { builder.add_array_bracket(x); }
      if let Some(x) = args.content { builder.add_content(x); }
      builder.add_sz(args.sz);
      builder.finish()
    }

    pub const VT_SZ: flatbuffers::VOffsetT = 4;
    pub const VT_CONTENT: flatbuffers::VOffsetT = 6;
    pub const VT_ARRAY_BRACKET: flatbuffers::VOffsetT = 8;
    pub const VT_ARRAY_ELEMENT: flatbuffers::VOffsetT = 10;
    pub const VT_TEXT: flatbuffers::VOffsetT = 12;
    pub const VT_BOOL: flatbuffers::VOffsetT = 14;
    pub const VT_NULL: flatbuffers::VOffsetT = 16;
    pub const VT_F64_: flatbuffers::VOffsetT = 18;
    pub const VT_F32_: flatbuffers::VOffsetT = 20;
    pub const VT_U64_: flatbuffers::VOffsetT = 22;
    pub const VT_I64_: flatbuffers::VOffsetT = 24;
    pub const VT_D64: flatbuffers::VOffsetT = 26;
    pub const VT_U32_: flatbuffers::VOffsetT = 28;
    pub const VT_I32_: flatbuffers::VOffsetT = 30;
    pub const VT_D32: flatbuffers::VOffsetT = 32;
    pub const VT_U16_: flatbuffers::VOffsetT = 34;
    pub const VT_I16_: flatbuffers::VOffsetT = 36;
    pub const VT_U8_: flatbuffers::VOffsetT = 38;
    pub const VT_I8_: flatbuffers::VOffsetT = 40;

  #[inline]
  pub fn sz(&self) -> u32 {
    self._tab.get::<u32>(SemiStructuredData::VT_SZ, Some(0)).unwrap()
  }
  #[inline]
  pub fn content(&self) -> Option<Content<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Content>>(SemiStructuredData::VT_CONTENT, None)
  }
  #[inline]
  pub fn array_bracket(&self) -> Option<ArrayBracket<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<ArrayBracket>>(SemiStructuredData::VT_ARRAY_BRACKET, None)
  }
  #[inline]
  pub fn array_element(&self) -> Option<ArrayElement<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<ArrayElement>>(SemiStructuredData::VT_ARRAY_ELEMENT, None)
  }
  #[inline]
  pub fn text(&self) -> Option<TextColumnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<TextColumnar>>(SemiStructuredData::VT_TEXT, None)
  }
  #[inline]
  pub fn bool(&self) -> Option<BoolColumnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BoolColumnar>>(SemiStructuredData::VT_BOOL, None)
  }
  #[inline]
  pub fn null(&self) -> Option<NullColumnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<NullColumnar>>(SemiStructuredData::VT_NULL, None)
  }
  #[inline]
  pub fn f64_(&self) -> Option<Float64Columnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Float64Columnar>>(SemiStructuredData::VT_F64_, None)
  }
  #[inline]
  pub fn f32_(&self) -> Option<Float32Columnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Float32Columnar>>(SemiStructuredData::VT_F32_, None)
  }
  #[inline]
  pub fn u64_(&self) -> Option<Uint64Columnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Uint64Columnar>>(SemiStructuredData::VT_U64_, None)
  }
  #[inline]
  pub fn i64_(&self) -> Option<Int64Columnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Int64Columnar>>(SemiStructuredData::VT_I64_, None)
  }
  #[inline]
  pub fn d64(&self) -> Option<Int64Columnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Int64Columnar>>(SemiStructuredData::VT_D64, None)
  }
  #[inline]
  pub fn u32_(&self) -> Option<Uint32Columnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Uint32Columnar>>(SemiStructuredData::VT_U32_, None)
  }
  #[inline]
  pub fn i32_(&self) -> Option<Int32Columnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Int32Columnar>>(SemiStructuredData::VT_I32_, None)
  }
  #[inline]
  pub fn d32(&self) -> Option<Int32Columnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Int32Columnar>>(SemiStructuredData::VT_D32, None)
  }
  #[inline]
  pub fn u16_(&self) -> Option<Uint16Columnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Uint16Columnar>>(SemiStructuredData::VT_U16_, None)
  }
  #[inline]
  pub fn i16_(&self) -> Option<Int16Columnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Int16Columnar>>(SemiStructuredData::VT_I16_, None)
  }
  #[inline]
  pub fn u8_(&self) -> Option<Uint8Columnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Uint8Columnar>>(SemiStructuredData::VT_U8_, None)
  }
  #[inline]
  pub fn i8_(&self) -> Option<Int8Columnar<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Int8Columnar>>(SemiStructuredData::VT_I8_, None)
  }
}

impl flatbuffers::Verifiable for SemiStructuredData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"sz", Self::VT_SZ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Content>>(&"content", Self::VT_CONTENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ArrayBracket>>(&"array_bracket", Self::VT_ARRAY_BRACKET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ArrayElement>>(&"array_element", Self::VT_ARRAY_ELEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TextColumnar>>(&"text", Self::VT_TEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BoolColumnar>>(&"bool", Self::VT_BOOL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<NullColumnar>>(&"null", Self::VT_NULL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Float64Columnar>>(&"f64_", Self::VT_F64_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Float32Columnar>>(&"f32_", Self::VT_F32_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uint64Columnar>>(&"u64_", Self::VT_U64_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Int64Columnar>>(&"i64_", Self::VT_I64_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Int64Columnar>>(&"d64", Self::VT_D64, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uint32Columnar>>(&"u32_", Self::VT_U32_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Int32Columnar>>(&"i32_", Self::VT_I32_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Int32Columnar>>(&"d32", Self::VT_D32, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uint16Columnar>>(&"u16_", Self::VT_U16_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Int16Columnar>>(&"i16_", Self::VT_I16_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uint8Columnar>>(&"u8_", Self::VT_U8_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Int8Columnar>>(&"i8_", Self::VT_I8_, false)?
     .finish();
    Ok(())
  }
}
pub struct SemiStructuredDataArgs<'a> {
    pub sz: u32,
    pub content: Option<flatbuffers::WIPOffset<Content<'a>>>,
    pub array_bracket: Option<flatbuffers::WIPOffset<ArrayBracket<'a>>>,
    pub array_element: Option<flatbuffers::WIPOffset<ArrayElement<'a>>>,
    pub text: Option<flatbuffers::WIPOffset<TextColumnar<'a>>>,
    pub bool: Option<flatbuffers::WIPOffset<BoolColumnar<'a>>>,
    pub null: Option<flatbuffers::WIPOffset<NullColumnar<'a>>>,
    pub f64_: Option<flatbuffers::WIPOffset<Float64Columnar<'a>>>,
    pub f32_: Option<flatbuffers::WIPOffset<Float32Columnar<'a>>>,
    pub u64_: Option<flatbuffers::WIPOffset<Uint64Columnar<'a>>>,
    pub i64_: Option<flatbuffers::WIPOffset<Int64Columnar<'a>>>,
    pub d64: Option<flatbuffers::WIPOffset<Int64Columnar<'a>>>,
    pub u32_: Option<flatbuffers::WIPOffset<Uint32Columnar<'a>>>,
    pub i32_: Option<flatbuffers::WIPOffset<Int32Columnar<'a>>>,
    pub d32: Option<flatbuffers::WIPOffset<Int32Columnar<'a>>>,
    pub u16_: Option<flatbuffers::WIPOffset<Uint16Columnar<'a>>>,
    pub i16_: Option<flatbuffers::WIPOffset<Int16Columnar<'a>>>,
    pub u8_: Option<flatbuffers::WIPOffset<Uint8Columnar<'a>>>,
    pub i8_: Option<flatbuffers::WIPOffset<Int8Columnar<'a>>>,
}
impl<'a> Default for SemiStructuredDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        SemiStructuredDataArgs {
            sz: 0,
            content: None,
            array_bracket: None,
            array_element: None,
            text: None,
            bool: None,
            null: None,
            f64_: None,
            f32_: None,
            u64_: None,
            i64_: None,
            d64: None,
            u32_: None,
            i32_: None,
            d32: None,
            u16_: None,
            i16_: None,
            u8_: None,
            i8_: None,
        }
    }
}
pub struct SemiStructuredDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SemiStructuredDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_sz(&mut self, sz: u32) {
    self.fbb_.push_slot::<u32>(SemiStructuredData::VT_SZ, sz, 0);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<Content<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Content>>(SemiStructuredData::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_array_bracket(&mut self, array_bracket: flatbuffers::WIPOffset<ArrayBracket<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ArrayBracket>>(SemiStructuredData::VT_ARRAY_BRACKET, array_bracket);
  }
  #[inline]
  pub fn add_array_element(&mut self, array_element: flatbuffers::WIPOffset<ArrayElement<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ArrayElement>>(SemiStructuredData::VT_ARRAY_ELEMENT, array_element);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<TextColumnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TextColumnar>>(SemiStructuredData::VT_TEXT, text);
  }
  #[inline]
  pub fn add_bool(&mut self, bool: flatbuffers::WIPOffset<BoolColumnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BoolColumnar>>(SemiStructuredData::VT_BOOL, bool);
  }
  #[inline]
  pub fn add_null(&mut self, null: flatbuffers::WIPOffset<NullColumnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<NullColumnar>>(SemiStructuredData::VT_NULL, null);
  }
  #[inline]
  pub fn add_f64_(&mut self, f64_: flatbuffers::WIPOffset<Float64Columnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Float64Columnar>>(SemiStructuredData::VT_F64_, f64_);
  }
  #[inline]
  pub fn add_f32_(&mut self, f32_: flatbuffers::WIPOffset<Float32Columnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Float32Columnar>>(SemiStructuredData::VT_F32_, f32_);
  }
  #[inline]
  pub fn add_u64_(&mut self, u64_: flatbuffers::WIPOffset<Uint64Columnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uint64Columnar>>(SemiStructuredData::VT_U64_, u64_);
  }
  #[inline]
  pub fn add_i64_(&mut self, i64_: flatbuffers::WIPOffset<Int64Columnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Int64Columnar>>(SemiStructuredData::VT_I64_, i64_);
  }
  #[inline]
  pub fn add_d64(&mut self, d64: flatbuffers::WIPOffset<Int64Columnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Int64Columnar>>(SemiStructuredData::VT_D64, d64);
  }
  #[inline]
  pub fn add_u32_(&mut self, u32_: flatbuffers::WIPOffset<Uint32Columnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uint32Columnar>>(SemiStructuredData::VT_U32_, u32_);
  }
  #[inline]
  pub fn add_i32_(&mut self, i32_: flatbuffers::WIPOffset<Int32Columnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Int32Columnar>>(SemiStructuredData::VT_I32_, i32_);
  }
  #[inline]
  pub fn add_d32(&mut self, d32: flatbuffers::WIPOffset<Int32Columnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Int32Columnar>>(SemiStructuredData::VT_D32, d32);
  }
  #[inline]
  pub fn add_u16_(&mut self, u16_: flatbuffers::WIPOffset<Uint16Columnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uint16Columnar>>(SemiStructuredData::VT_U16_, u16_);
  }
  #[inline]
  pub fn add_i16_(&mut self, i16_: flatbuffers::WIPOffset<Int16Columnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Int16Columnar>>(SemiStructuredData::VT_I16_, i16_);
  }
  #[inline]
  pub fn add_u8_(&mut self, u8_: flatbuffers::WIPOffset<Uint8Columnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uint8Columnar>>(SemiStructuredData::VT_U8_, u8_);
  }
  #[inline]
  pub fn add_i8_(&mut self, i8_: flatbuffers::WIPOffset<Int8Columnar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Int8Columnar>>(SemiStructuredData::VT_I8_, i8_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SemiStructuredDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SemiStructuredDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SemiStructuredData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SemiStructuredData<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SemiStructuredData");
      ds.field("sz", &self.sz());
      ds.field("content", &self.content());
      ds.field("array_bracket", &self.array_bracket());
      ds.field("array_element", &self.array_element());
      ds.field("text", &self.text());
      ds.field("bool", &self.bool());
      ds.field("null", &self.null());
      ds.field("f64_", &self.f64_());
      ds.field("f32_", &self.f32_());
      ds.field("u64_", &self.u64_());
      ds.field("i64_", &self.i64_());
      ds.field("d64", &self.d64());
      ds.field("u32_", &self.u32_());
      ds.field("i32_", &self.i32_());
      ds.field("d32", &self.d32());
      ds.field("u16_", &self.u16_());
      ds.field("i16_", &self.i16_());
      ds.field("u8_", &self.u8_());
      ds.field("i8_", &self.i8_());
      ds.finish()
  }
}
pub enum BoolColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoolColumn<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoolColumn<'a> {
    type Inner = BoolColumn<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> BoolColumn<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BoolColumn { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BoolColumnArgs<'args>) -> flatbuffers::WIPOffset<BoolColumn<'bldr>> {
      let mut builder = BoolColumnBuilder::new(_fbb);
      if let Some(x) = args.bool { builder.add_bool(x); }
      builder.add_unicode(args.unicode);
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_BOOL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn unicode(&self) -> u32 {
    self._tab.get::<u32>(BoolColumn::VT_UNICODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn bool(&self) -> Option<&'a [bool]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(BoolColumn::VT_BOOL, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for BoolColumn<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>(&"bool", Self::VT_BOOL, false)?
     .finish();
    Ok(())
  }
}
pub struct BoolColumnArgs<'a> {
    pub unicode: u32,
    pub bool: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
}
impl<'a> Default for BoolColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        BoolColumnArgs {
            unicode: 0,
            bool: None,
        }
    }
}
pub struct BoolColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BoolColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: u32) {
    self.fbb_.push_slot::<u32>(BoolColumn::VT_UNICODE, unicode, 0);
  }
  #[inline]
  pub fn add_bool(&mut self, bool: flatbuffers::WIPOffset<flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoolColumn::VT_BOOL, bool);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoolColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BoolColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoolColumn<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for BoolColumn<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("BoolColumn");
      ds.field("unicode", &self.unicode());
      ds.field("bool", &self.bool());
      ds.finish()
  }
}
pub enum NullColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NullColumn<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NullColumn<'a> {
    type Inner = NullColumn<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> NullColumn<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NullColumn { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NullColumnArgs<'args>) -> flatbuffers::WIPOffset<NullColumn<'bldr>> {
      let mut builder = NullColumnBuilder::new(_fbb);
      if let Some(x) = args.null { builder.add_null(x); }
      builder.add_unicode(args.unicode);
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_NULL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn unicode(&self) -> u32 {
    self._tab.get::<u32>(NullColumn::VT_UNICODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn null(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(NullColumn::VT_NULL, None)
  }
}

impl flatbuffers::Verifiable for NullColumn<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"null", Self::VT_NULL, false)?
     .finish();
    Ok(())
  }
}
pub struct NullColumnArgs<'a> {
    pub unicode: u32,
    pub null: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for NullColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        NullColumnArgs {
            unicode: 0,
            null: None,
        }
    }
}
pub struct NullColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NullColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: u32) {
    self.fbb_.push_slot::<u32>(NullColumn::VT_UNICODE, unicode, 0);
  }
  #[inline]
  pub fn add_null(&mut self, null: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NullColumn::VT_NULL, null);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NullColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NullColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NullColumn<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for NullColumn<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("NullColumn");
      ds.field("unicode", &self.unicode());
      ds.field("null", &self.null());
      ds.finish()
  }
}
pub enum Float64ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Float64Column<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Float64Column<'a> {
    type Inner = Float64Column<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Float64Column<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Float64Column { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Float64ColumnArgs<'args>) -> flatbuffers::WIPOffset<Float64Column<'bldr>> {
      let mut builder = Float64ColumnBuilder::new(_fbb);
      if let Some(x) = args.float64 { builder.add_float64(x); }
      builder.add_unicode(args.unicode);
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_FLOAT64: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn unicode(&self) -> u32 {
    self._tab.get::<u32>(Float64Column::VT_UNICODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn float64(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Float64Column::VT_FLOAT64, None)
  }
}

impl flatbuffers::Verifiable for Float64Column<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"float64", Self::VT_FLOAT64, false)?
     .finish();
    Ok(())
  }
}
pub struct Float64ColumnArgs<'a> {
    pub unicode: u32,
    pub float64: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for Float64ColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        Float64ColumnArgs {
            unicode: 0,
            float64: None,
        }
    }
}
pub struct Float64ColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Float64ColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: u32) {
    self.fbb_.push_slot::<u32>(Float64Column::VT_UNICODE, unicode, 0);
  }
  #[inline]
  pub fn add_float64(&mut self, float64: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Float64Column::VT_FLOAT64, float64);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Float64ColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Float64ColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Float64Column<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Float64Column<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Float64Column");
      ds.field("unicode", &self.unicode());
      ds.field("float64", &self.float64());
      ds.finish()
  }
}
pub enum Float32ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Float32Column<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Float32Column<'a> {
    type Inner = Float32Column<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Float32Column<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Float32Column { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Float32ColumnArgs<'args>) -> flatbuffers::WIPOffset<Float32Column<'bldr>> {
      let mut builder = Float32ColumnBuilder::new(_fbb);
      if let Some(x) = args.float { builder.add_float(x); }
      builder.add_unicode(args.unicode);
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_FLOAT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn unicode(&self) -> u32 {
    self._tab.get::<u32>(Float32Column::VT_UNICODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn float(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(Float32Column::VT_FLOAT, None)
  }
}

impl flatbuffers::Verifiable for Float32Column<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(&"float", Self::VT_FLOAT, false)?
     .finish();
    Ok(())
  }
}
pub struct Float32ColumnArgs<'a> {
    pub unicode: u32,
    pub float: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for Float32ColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        Float32ColumnArgs {
            unicode: 0,
            float: None,
        }
    }
}
pub struct Float32ColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Float32ColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: u32) {
    self.fbb_.push_slot::<u32>(Float32Column::VT_UNICODE, unicode, 0);
  }
  #[inline]
  pub fn add_float(&mut self, float: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Float32Column::VT_FLOAT, float);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Float32ColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Float32ColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Float32Column<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Float32Column<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Float32Column");
      ds.field("unicode", &self.unicode());
      ds.field("float", &self.float());
      ds.finish()
  }
}
pub enum Uint64ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Uint64Column<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uint64Column<'a> {
    type Inner = Uint64Column<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Uint64Column<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Uint64Column { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Uint64ColumnArgs<'args>) -> flatbuffers::WIPOffset<Uint64Column<'bldr>> {
      let mut builder = Uint64ColumnBuilder::new(_fbb);
      if let Some(x) = args.uint64 { builder.add_uint64(x); }
      builder.add_unicode(args.unicode);
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_UINT64: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn unicode(&self) -> u32 {
    self._tab.get::<u32>(Uint64Column::VT_UNICODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn uint64(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Uint64Column::VT_UINT64, None)
  }
}

impl flatbuffers::Verifiable for Uint64Column<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(&"uint64", Self::VT_UINT64, false)?
     .finish();
    Ok(())
  }
}
pub struct Uint64ColumnArgs<'a> {
    pub unicode: u32,
    pub uint64: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for Uint64ColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        Uint64ColumnArgs {
            unicode: 0,
            uint64: None,
        }
    }
}
pub struct Uint64ColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Uint64ColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: u32) {
    self.fbb_.push_slot::<u32>(Uint64Column::VT_UNICODE, unicode, 0);
  }
  #[inline]
  pub fn add_uint64(&mut self, uint64: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Uint64Column::VT_UINT64, uint64);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Uint64ColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Uint64ColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uint64Column<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Uint64Column<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Uint64Column");
      ds.field("unicode", &self.unicode());
      ds.field("uint64", &self.uint64());
      ds.finish()
  }
}
pub enum Int64ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int64Column<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int64Column<'a> {
    type Inner = Int64Column<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Int64Column<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Int64Column { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Int64ColumnArgs<'args>) -> flatbuffers::WIPOffset<Int64Column<'bldr>> {
      let mut builder = Int64ColumnBuilder::new(_fbb);
      if let Some(x) = args.int64 { builder.add_int64(x); }
      builder.add_unicode(args.unicode);
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_INT64: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn unicode(&self) -> u32 {
    self._tab.get::<u32>(Int64Column::VT_UNICODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn int64(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(Int64Column::VT_INT64, None)
  }
}

impl flatbuffers::Verifiable for Int64Column<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>(&"int64", Self::VT_INT64, false)?
     .finish();
    Ok(())
  }
}
pub struct Int64ColumnArgs<'a> {
    pub unicode: u32,
    pub int64: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for Int64ColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        Int64ColumnArgs {
            unicode: 0,
            int64: None,
        }
    }
}
pub struct Int64ColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Int64ColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: u32) {
    self.fbb_.push_slot::<u32>(Int64Column::VT_UNICODE, unicode, 0);
  }
  #[inline]
  pub fn add_int64(&mut self, int64: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Int64Column::VT_INT64, int64);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Int64ColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Int64ColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Int64Column<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Int64Column<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Int64Column");
      ds.field("unicode", &self.unicode());
      ds.field("int64", &self.int64());
      ds.finish()
  }
}
pub enum Uint32ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Uint32Column<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uint32Column<'a> {
    type Inner = Uint32Column<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Uint32Column<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Uint32Column { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Uint32ColumnArgs<'args>) -> flatbuffers::WIPOffset<Uint32Column<'bldr>> {
      let mut builder = Uint32ColumnBuilder::new(_fbb);
      if let Some(x) = args.uint32 { builder.add_uint32(x); }
      builder.add_unicode(args.unicode);
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_UINT32: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn unicode(&self) -> u32 {
    self._tab.get::<u32>(Uint32Column::VT_UNICODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn uint32(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Uint32Column::VT_UINT32, None)
  }
}

impl flatbuffers::Verifiable for Uint32Column<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"uint32", Self::VT_UINT32, false)?
     .finish();
    Ok(())
  }
}
pub struct Uint32ColumnArgs<'a> {
    pub unicode: u32,
    pub uint32: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for Uint32ColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        Uint32ColumnArgs {
            unicode: 0,
            uint32: None,
        }
    }
}
pub struct Uint32ColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Uint32ColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: u32) {
    self.fbb_.push_slot::<u32>(Uint32Column::VT_UNICODE, unicode, 0);
  }
  #[inline]
  pub fn add_uint32(&mut self, uint32: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Uint32Column::VT_UINT32, uint32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Uint32ColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Uint32ColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uint32Column<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Uint32Column<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Uint32Column");
      ds.field("unicode", &self.unicode());
      ds.field("uint32", &self.uint32());
      ds.finish()
  }
}
pub enum Int32ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int32Column<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int32Column<'a> {
    type Inner = Int32Column<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Int32Column<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Int32Column { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Int32ColumnArgs<'args>) -> flatbuffers::WIPOffset<Int32Column<'bldr>> {
      let mut builder = Int32ColumnBuilder::new(_fbb);
      if let Some(x) = args.int32 { builder.add_int32(x); }
      builder.add_unicode(args.unicode);
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_INT32: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn unicode(&self) -> u32 {
    self._tab.get::<u32>(Int32Column::VT_UNICODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn int32(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Int32Column::VT_INT32, None)
  }
}

impl flatbuffers::Verifiable for Int32Column<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"int32", Self::VT_INT32, false)?
     .finish();
    Ok(())
  }
}
pub struct Int32ColumnArgs<'a> {
    pub unicode: u32,
    pub int32: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for Int32ColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        Int32ColumnArgs {
            unicode: 0,
            int32: None,
        }
    }
}
pub struct Int32ColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Int32ColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: u32) {
    self.fbb_.push_slot::<u32>(Int32Column::VT_UNICODE, unicode, 0);
  }
  #[inline]
  pub fn add_int32(&mut self, int32: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Int32Column::VT_INT32, int32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Int32ColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Int32ColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Int32Column<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Int32Column<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Int32Column");
      ds.field("unicode", &self.unicode());
      ds.field("int32", &self.int32());
      ds.finish()
  }
}
pub enum Uint16ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Uint16Column<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uint16Column<'a> {
    type Inner = Uint16Column<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Uint16Column<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Uint16Column { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Uint16ColumnArgs<'args>) -> flatbuffers::WIPOffset<Uint16Column<'bldr>> {
      let mut builder = Uint16ColumnBuilder::new(_fbb);
      if let Some(x) = args.uint16 { builder.add_uint16(x); }
      builder.add_unicode(args.unicode);
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_UINT16: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn unicode(&self) -> u32 {
    self._tab.get::<u32>(Uint16Column::VT_UNICODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn uint16(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Uint16Column::VT_UINT16, None)
  }
}

impl flatbuffers::Verifiable for Uint16Column<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"uint16", Self::VT_UINT16, false)?
     .finish();
    Ok(())
  }
}
pub struct Uint16ColumnArgs<'a> {
    pub unicode: u32,
    pub uint16: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for Uint16ColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        Uint16ColumnArgs {
            unicode: 0,
            uint16: None,
        }
    }
}
pub struct Uint16ColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Uint16ColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: u32) {
    self.fbb_.push_slot::<u32>(Uint16Column::VT_UNICODE, unicode, 0);
  }
  #[inline]
  pub fn add_uint16(&mut self, uint16: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Uint16Column::VT_UINT16, uint16);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Uint16ColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Uint16ColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uint16Column<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Uint16Column<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Uint16Column");
      ds.field("unicode", &self.unicode());
      ds.field("uint16", &self.uint16());
      ds.finish()
  }
}
pub enum Int16ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int16Column<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int16Column<'a> {
    type Inner = Int16Column<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Int16Column<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Int16Column { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Int16ColumnArgs<'args>) -> flatbuffers::WIPOffset<Int16Column<'bldr>> {
      let mut builder = Int16ColumnBuilder::new(_fbb);
      if let Some(x) = args.int16 { builder.add_int16(x); }
      builder.add_unicode(args.unicode);
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_INT16: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn unicode(&self) -> u32 {
    self._tab.get::<u32>(Int16Column::VT_UNICODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn int16(&self) -> Option<flatbuffers::Vector<'a, i16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i16>>>(Int16Column::VT_INT16, None)
  }
}

impl flatbuffers::Verifiable for Int16Column<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i16>>>(&"int16", Self::VT_INT16, false)?
     .finish();
    Ok(())
  }
}
pub struct Int16ColumnArgs<'a> {
    pub unicode: u32,
    pub int16: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i16>>>,
}
impl<'a> Default for Int16ColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        Int16ColumnArgs {
            unicode: 0,
            int16: None,
        }
    }
}
pub struct Int16ColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Int16ColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: u32) {
    self.fbb_.push_slot::<u32>(Int16Column::VT_UNICODE, unicode, 0);
  }
  #[inline]
  pub fn add_int16(&mut self, int16: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Int16Column::VT_INT16, int16);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Int16ColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Int16ColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Int16Column<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Int16Column<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Int16Column");
      ds.field("unicode", &self.unicode());
      ds.field("int16", &self.int16());
      ds.finish()
  }
}
pub enum Uint8ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Uint8Column<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uint8Column<'a> {
    type Inner = Uint8Column<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Uint8Column<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Uint8Column { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Uint8ColumnArgs<'args>) -> flatbuffers::WIPOffset<Uint8Column<'bldr>> {
      let mut builder = Uint8ColumnBuilder::new(_fbb);
      if let Some(x) = args.uint8 { builder.add_uint8(x); }
      builder.add_unicode(args.unicode);
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_UINT8: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn unicode(&self) -> u32 {
    self._tab.get::<u32>(Uint8Column::VT_UNICODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn uint8(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Uint8Column::VT_UINT8, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Uint8Column<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"uint8", Self::VT_UINT8, false)?
     .finish();
    Ok(())
  }
}
pub struct Uint8ColumnArgs<'a> {
    pub unicode: u32,
    pub uint8: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for Uint8ColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        Uint8ColumnArgs {
            unicode: 0,
            uint8: None,
        }
    }
}
pub struct Uint8ColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Uint8ColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: u32) {
    self.fbb_.push_slot::<u32>(Uint8Column::VT_UNICODE, unicode, 0);
  }
  #[inline]
  pub fn add_uint8(&mut self, uint8: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Uint8Column::VT_UINT8, uint8);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Uint8ColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Uint8ColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uint8Column<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Uint8Column<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Uint8Column");
      ds.field("unicode", &self.unicode());
      ds.field("uint8", &self.uint8());
      ds.finish()
  }
}
pub enum Int8ColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int8Column<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int8Column<'a> {
    type Inner = Int8Column<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Int8Column<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Int8Column { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Int8ColumnArgs<'args>) -> flatbuffers::WIPOffset<Int8Column<'bldr>> {
      let mut builder = Int8ColumnBuilder::new(_fbb);
      if let Some(x) = args.int8 { builder.add_int8(x); }
      builder.add_unicode(args.unicode);
      builder.finish()
    }

    pub const VT_UNICODE: flatbuffers::VOffsetT = 4;
    pub const VT_INT8: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn unicode(&self) -> u32 {
    self._tab.get::<u32>(Int8Column::VT_UNICODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn int8(&self) -> Option<&'a [i8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(Int8Column::VT_INT8, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Int8Column<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"unicode", Self::VT_UNICODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(&"int8", Self::VT_INT8, false)?
     .finish();
    Ok(())
  }
}
pub struct Int8ColumnArgs<'a> {
    pub unicode: u32,
    pub int8: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for Int8ColumnArgs<'a> {
    #[inline]
    fn default() -> Self {
        Int8ColumnArgs {
            unicode: 0,
            int8: None,
        }
    }
}
pub struct Int8ColumnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Int8ColumnBuilder<'a, 'b> {
  #[inline]
  pub fn add_unicode(&mut self, unicode: u32) {
    self.fbb_.push_slot::<u32>(Int8Column::VT_UNICODE, unicode, 0);
  }
  #[inline]
  pub fn add_int8(&mut self, int8: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Int8Column::VT_INT8, int8);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Int8ColumnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Int8ColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Int8Column<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Int8Column<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Int8Column");
      ds.field("unicode", &self.unicode());
      ds.field("int8", &self.int8());
      ds.finish()
  }
}
pub enum ColumnizedEntityOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ColumnizedEntity<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ColumnizedEntity<'a> {
    type Inner = ColumnizedEntity<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ColumnizedEntity<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ColumnizedEntity { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ColumnizedEntityArgs<'args>) -> flatbuffers::WIPOffset<ColumnizedEntity<'bldr>> {
      let mut builder = ColumnizedEntityBuilder::new(_fbb);
      if let Some(x) = args.array_element { builder.add_array_element(x); }
      if let Some(x) = args.array_bracket { builder.add_array_bracket(x); }
      if let Some(x) = args.null { builder.add_null(x); }
      if let Some(x) = args.bool { builder.add_bool(x); }
      if let Some(x) = args.text { builder.add_text(x); }
      if let Some(x) = args.d64 { builder.add_d64(x); }
      if let Some(x) = args.f64_ { builder.add_f64_(x); }
      if let Some(x) = args.u64_ { builder.add_u64_(x); }
      if let Some(x) = args.i64_ { builder.add_i64_(x); }
      if let Some(x) = args.d32 { builder.add_d32(x); }
      if let Some(x) = args.f32_ { builder.add_f32_(x); }
      if let Some(x) = args.u32_ { builder.add_u32_(x); }
      if let Some(x) = args.i32_ { builder.add_i32_(x); }
      if let Some(x) = args.u16_ { builder.add_u16_(x); }
      if let Some(x) = args.i16_ { builder.add_i16_(x); }
      if let Some(x) = args.u8_ { builder.add_u8_(x); }
      if let Some(x) = args.i8_ { builder.add_i8_(x); }
      builder.finish()
    }

    pub const VT_I8_: flatbuffers::VOffsetT = 4;
    pub const VT_U8_: flatbuffers::VOffsetT = 6;
    pub const VT_I16_: flatbuffers::VOffsetT = 8;
    pub const VT_U16_: flatbuffers::VOffsetT = 10;
    pub const VT_I32_: flatbuffers::VOffsetT = 12;
    pub const VT_U32_: flatbuffers::VOffsetT = 14;
    pub const VT_F32_: flatbuffers::VOffsetT = 16;
    pub const VT_D32: flatbuffers::VOffsetT = 18;
    pub const VT_I64_: flatbuffers::VOffsetT = 20;
    pub const VT_U64_: flatbuffers::VOffsetT = 22;
    pub const VT_F64_: flatbuffers::VOffsetT = 24;
    pub const VT_D64: flatbuffers::VOffsetT = 26;
    pub const VT_TEXT: flatbuffers::VOffsetT = 28;
    pub const VT_BOOL: flatbuffers::VOffsetT = 30;
    pub const VT_NULL: flatbuffers::VOffsetT = 32;
    pub const VT_ARRAY_BRACKET: flatbuffers::VOffsetT = 34;
    pub const VT_ARRAY_ELEMENT: flatbuffers::VOffsetT = 36;

  #[inline]
  pub fn i8_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int8Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int8Column>>>>(ColumnizedEntity::VT_I8_, None)
  }
  #[inline]
  pub fn u8_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint8Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint8Column>>>>(ColumnizedEntity::VT_U8_, None)
  }
  #[inline]
  pub fn i16_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int16Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int16Column>>>>(ColumnizedEntity::VT_I16_, None)
  }
  #[inline]
  pub fn u16_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint16Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint16Column>>>>(ColumnizedEntity::VT_U16_, None)
  }
  #[inline]
  pub fn i32_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int32Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int32Column>>>>(ColumnizedEntity::VT_I32_, None)
  }
  #[inline]
  pub fn u32_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint32Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint32Column>>>>(ColumnizedEntity::VT_U32_, None)
  }
  #[inline]
  pub fn f32_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Float32Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Float32Column>>>>(ColumnizedEntity::VT_F32_, None)
  }
  #[inline]
  pub fn d32(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int32Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int32Column>>>>(ColumnizedEntity::VT_D32, None)
  }
  #[inline]
  pub fn i64_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int64Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int64Column>>>>(ColumnizedEntity::VT_I64_, None)
  }
  #[inline]
  pub fn u64_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint64Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint64Column>>>>(ColumnizedEntity::VT_U64_, None)
  }
  #[inline]
  pub fn f64_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Float64Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Float64Column>>>>(ColumnizedEntity::VT_F64_, None)
  }
  #[inline]
  pub fn d64(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int64Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int64Column>>>>(ColumnizedEntity::VT_D64, None)
  }
  #[inline]
  pub fn text(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint32Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint32Column>>>>(ColumnizedEntity::VT_TEXT, None)
  }
  #[inline]
  pub fn bool(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoolColumn<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoolColumn>>>>(ColumnizedEntity::VT_BOOL, None)
  }
  #[inline]
  pub fn null(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NullColumn<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NullColumn>>>>(ColumnizedEntity::VT_NULL, None)
  }
  #[inline]
  pub fn array_bracket(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint16Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint16Column>>>>(ColumnizedEntity::VT_ARRAY_BRACKET, None)
  }
  #[inline]
  pub fn array_element(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint16Column<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint16Column>>>>(ColumnizedEntity::VT_ARRAY_ELEMENT, None)
  }
}

impl flatbuffers::Verifiable for ColumnizedEntity<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Int8Column>>>>(&"i8_", Self::VT_I8_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Uint8Column>>>>(&"u8_", Self::VT_U8_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Int16Column>>>>(&"i16_", Self::VT_I16_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Uint16Column>>>>(&"u16_", Self::VT_U16_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Int32Column>>>>(&"i32_", Self::VT_I32_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Uint32Column>>>>(&"u32_", Self::VT_U32_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Float32Column>>>>(&"f32_", Self::VT_F32_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Int32Column>>>>(&"d32", Self::VT_D32, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Int64Column>>>>(&"i64_", Self::VT_I64_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Uint64Column>>>>(&"u64_", Self::VT_U64_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Float64Column>>>>(&"f64_", Self::VT_F64_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Int64Column>>>>(&"d64", Self::VT_D64, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Uint32Column>>>>(&"text", Self::VT_TEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoolColumn>>>>(&"bool", Self::VT_BOOL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<NullColumn>>>>(&"null", Self::VT_NULL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Uint16Column>>>>(&"array_bracket", Self::VT_ARRAY_BRACKET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Uint16Column>>>>(&"array_element", Self::VT_ARRAY_ELEMENT, false)?
     .finish();
    Ok(())
  }
}
pub struct ColumnizedEntityArgs<'a> {
    pub i8_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int8Column<'a>>>>>,
    pub u8_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint8Column<'a>>>>>,
    pub i16_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int16Column<'a>>>>>,
    pub u16_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint16Column<'a>>>>>,
    pub i32_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int32Column<'a>>>>>,
    pub u32_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint32Column<'a>>>>>,
    pub f32_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Float32Column<'a>>>>>,
    pub d32: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int32Column<'a>>>>>,
    pub i64_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int64Column<'a>>>>>,
    pub u64_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint64Column<'a>>>>>,
    pub f64_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Float64Column<'a>>>>>,
    pub d64: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Int64Column<'a>>>>>,
    pub text: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint32Column<'a>>>>>,
    pub bool: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoolColumn<'a>>>>>,
    pub null: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NullColumn<'a>>>>>,
    pub array_bracket: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint16Column<'a>>>>>,
    pub array_element: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Uint16Column<'a>>>>>,
}
impl<'a> Default for ColumnizedEntityArgs<'a> {
    #[inline]
    fn default() -> Self {
        ColumnizedEntityArgs {
            i8_: None,
            u8_: None,
            i16_: None,
            u16_: None,
            i32_: None,
            u32_: None,
            f32_: None,
            d32: None,
            i64_: None,
            u64_: None,
            f64_: None,
            d64: None,
            text: None,
            bool: None,
            null: None,
            array_bracket: None,
            array_element: None,
        }
    }
}
pub struct ColumnizedEntityBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ColumnizedEntityBuilder<'a, 'b> {
  #[inline]
  pub fn add_i8_(&mut self, i8_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Int8Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_I8_, i8_);
  }
  #[inline]
  pub fn add_u8_(&mut self, u8_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Uint8Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_U8_, u8_);
  }
  #[inline]
  pub fn add_i16_(&mut self, i16_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Int16Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_I16_, i16_);
  }
  #[inline]
  pub fn add_u16_(&mut self, u16_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Uint16Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_U16_, u16_);
  }
  #[inline]
  pub fn add_i32_(&mut self, i32_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Int32Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_I32_, i32_);
  }
  #[inline]
  pub fn add_u32_(&mut self, u32_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Uint32Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_U32_, u32_);
  }
  #[inline]
  pub fn add_f32_(&mut self, f32_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Float32Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_F32_, f32_);
  }
  #[inline]
  pub fn add_d32(&mut self, d32: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Int32Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_D32, d32);
  }
  #[inline]
  pub fn add_i64_(&mut self, i64_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Int64Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_I64_, i64_);
  }
  #[inline]
  pub fn add_u64_(&mut self, u64_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Uint64Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_U64_, u64_);
  }
  #[inline]
  pub fn add_f64_(&mut self, f64_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Float64Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_F64_, f64_);
  }
  #[inline]
  pub fn add_d64(&mut self, d64: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Int64Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_D64, d64);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Uint32Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_TEXT, text);
  }
  #[inline]
  pub fn add_bool(&mut self, bool: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BoolColumn<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_BOOL, bool);
  }
  #[inline]
  pub fn add_null(&mut self, null: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<NullColumn<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_NULL, null);
  }
  #[inline]
  pub fn add_array_bracket(&mut self, array_bracket: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Uint16Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_ARRAY_BRACKET, array_bracket);
  }
  #[inline]
  pub fn add_array_element(&mut self, array_element: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Uint16Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntity::VT_ARRAY_ELEMENT, array_element);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ColumnizedEntityBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ColumnizedEntityBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ColumnizedEntity<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ColumnizedEntity<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ColumnizedEntity");
      ds.field("i8_", &self.i8_());
      ds.field("u8_", &self.u8_());
      ds.field("i16_", &self.i16_());
      ds.field("u16_", &self.u16_());
      ds.field("i32_", &self.i32_());
      ds.field("u32_", &self.u32_());
      ds.field("f32_", &self.f32_());
      ds.field("d32", &self.d32());
      ds.field("i64_", &self.i64_());
      ds.field("u64_", &self.u64_());
      ds.field("f64_", &self.f64_());
      ds.field("d64", &self.d64());
      ds.field("text", &self.text());
      ds.field("bool", &self.bool());
      ds.field("null", &self.null());
      ds.field("array_bracket", &self.array_bracket());
      ds.field("array_element", &self.array_element());
      ds.finish()
  }
}
pub enum ColumnizedEntitiesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ColumnizedEntities<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ColumnizedEntities<'a> {
    type Inner = ColumnizedEntities<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ColumnizedEntities<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ColumnizedEntities { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ColumnizedEntitiesArgs<'args>) -> flatbuffers::WIPOffset<ColumnizedEntities<'bldr>> {
      let mut builder = ColumnizedEntitiesBuilder::new(_fbb);
      if let Some(x) = args.text_content { builder.add_text_content(x); }
      if let Some(x) = args.entities { builder.add_entities(x); }
      builder.finish()
    }

    pub const VT_ENTITIES: flatbuffers::VOffsetT = 4;
    pub const VT_TEXT_CONTENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn entities(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ColumnizedEntity<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ColumnizedEntity>>>>(ColumnizedEntities::VT_ENTITIES, None)
  }
  #[inline]
  pub fn text_content(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ColumnizedEntities::VT_TEXT_CONTENT, None)
  }
}

impl flatbuffers::Verifiable for ColumnizedEntities<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ColumnizedEntity>>>>(&"entities", Self::VT_ENTITIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>(&"text_content", Self::VT_TEXT_CONTENT, false)?
     .finish();
    Ok(())
  }
}
pub struct ColumnizedEntitiesArgs<'a> {
    pub entities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ColumnizedEntity<'a>>>>>,
    pub text_content: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ColumnizedEntitiesArgs<'a> {
    #[inline]
    fn default() -> Self {
        ColumnizedEntitiesArgs {
            entities: None,
            text_content: None,
        }
    }
}
pub struct ColumnizedEntitiesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ColumnizedEntitiesBuilder<'a, 'b> {
  #[inline]
  pub fn add_entities(&mut self, entities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ColumnizedEntity<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntities::VT_ENTITIES, entities);
  }
  #[inline]
  pub fn add_text_content(&mut self, text_content: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnizedEntities::VT_TEXT_CONTENT, text_content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ColumnizedEntitiesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ColumnizedEntitiesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ColumnizedEntities<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ColumnizedEntities<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ColumnizedEntities");
      ds.field("entities", &self.entities());
      ds.field("text_content", &self.text_content());
      ds.finish()
  }
}
pub enum ClusterQueryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ClusterQuery<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClusterQuery<'a> {
    type Inner = ClusterQuery<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ClusterQuery<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ClusterQuery { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ClusterQueryArgs<'args>) -> flatbuffers::WIPOffset<ClusterQuery<'bldr>> {
      let mut builder = ClusterQueryBuilder::new(_fbb);
      builder.add_local(args.local);
      if let Some(x) = args.hosts { builder.add_hosts(x); }
      if let Some(x) = args.ssql { builder.add_ssql(x); }
      builder.finish()
    }

    pub const VT_SSQL: flatbuffers::VOffsetT = 4;
    pub const VT_HOSTS: flatbuffers::VOffsetT = 6;
    pub const VT_LOCAL: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn ssql(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ClusterQuery::VT_SSQL, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn hosts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ClusterQuery::VT_HOSTS, None)
  }
  #[inline]
  pub fn local(&self) -> i32 {
    self._tab.get::<i32>(ClusterQuery::VT_LOCAL, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for ClusterQuery<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"ssql", Self::VT_SSQL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>(&"hosts", Self::VT_HOSTS, false)?
     .visit_field::<i32>(&"local", Self::VT_LOCAL, false)?
     .finish();
    Ok(())
  }
}
pub struct ClusterQueryArgs<'a> {
    pub ssql: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub hosts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub local: i32,
}
impl<'a> Default for ClusterQueryArgs<'a> {
    #[inline]
    fn default() -> Self {
        ClusterQueryArgs {
            ssql: None,
            hosts: None,
            local: 0,
        }
    }
}
pub struct ClusterQueryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ClusterQueryBuilder<'a, 'b> {
  #[inline]
  pub fn add_ssql(&mut self, ssql: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClusterQuery::VT_SSQL, ssql);
  }
  #[inline]
  pub fn add_hosts(&mut self, hosts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClusterQuery::VT_HOSTS, hosts);
  }
  #[inline]
  pub fn add_local(&mut self, local: i32) {
    self.fbb_.push_slot::<i32>(ClusterQuery::VT_LOCAL, local, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ClusterQueryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ClusterQueryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ClusterQuery<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ClusterQuery<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ClusterQuery");
      ds.field("ssql", &self.ssql());
      ds.field("hosts", &self.hosts());
      ds.field("local", &self.local());
      ds.finish()
  }
}

pub static TEXT_LUT: [Marker; 3] = [
    Marker::SENTINEL,
    Marker::SOH,
    Marker::FRAG,
];